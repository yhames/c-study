# 전문가를 위한 C - Chapter 1 필수요소 : 전처리기 지시자

- [전문가를 위한 C - Chapter 1 필수요소 : 전처리기 지시자](#전문가를-위한-c---chapter-1-필수요소--전처리기-지시자)
  - [매크로](#매크로)
    - [매크로 정의하기](#매크로-정의하기)
    - [매크로 연산자](#매크로-연산자)
    - [가변 인자 매크로](#가변-인자-매크로)
    - [루프 풀기](#루프-풀기)
    - [매크로의 장점과 단점](#매크로의-장점과-단점)
  - [조건부 컴파일](#조건부-컴파일)
    - [헤더 가드 구문](#헤더-가드-구문)

## 매크로

### 매크로 정의하기

매크로는 `#define` 지시자를 사용하여 정의한다.

매크로는 `#undef` 지시자를 사용하여 정의를 제거할 수 있다.

매크로는 `이름`과 `값` 그리고 `매개변수 리스트`를 갖는다.

매개변수 리스트를 갖는 매크로는 `유사 함수 매크로`(function-like macro)라고 하며, 이는 `C` 함수와는 다르다.

매크로는 전처리 단계에서 `매크로 확장`을 통해 매크로 값으로 <U>**대체**</U>된다.

즉, 매크로는 컴파일 이전에 코드를 <U>**생성**</U>하는 것이다.

gcc에서 -E 옵션을 통해 전처리가 완료된 코드를 볼 수 있는데,
이를 확인해보면 모든 전처리기 지시자와 매크로를 정의하는 코드는 사라지고
매크로 이름이 매크로의 값으로 <U>**변환**</U>되어있는 것을 알 수 있다.

추가로 `#include` 같은 전처리기 지시자는 자신이 가리키는 파일의 내용으로 대체된다.

전처리가 완료된 코드를 보면, 상단에 굉장히 많은 내용이 포함되어 있는데 매크로 확장과 더불어 다른 전처리 지시자를 통해 가져온 코드가 포함되어있는 것이다.

컴파일러에서 사용하는 코드는 모든 지시자가 포함되거나 매크로 확장으로 대체된 "전처리된 C 코드"이다.

하지만 현대의 컴파일러가 전처리기의 존재 혹은 전처리 이전의 코드를 전혀 모른다고 생각해서는 안된다.

실제로 컴파일을 해보면 매크로에 대한 warning이나 error를 표시해준다.

추가로 코드를 대체 혹은 생성하는 매크로의 특징으로 인해 매크로는 `DSL`(도메인 특화 언어)을 정의하고 `DSL`을 이용해 코드를 작성하는데 활용 된다.

### 매크로 연산자

매크로는 매개변수와 관련해서 두 가지 연산자가 있다.(~~가변 인자 매크로까지 포함하면 3개~~)

`#` 연산자는 매개변수를 쌍따옴표로 둘러싼 <U>**문자열**</U>로 치환한다.  
예를 들어, `1`을 입력해도 `#` 연산자를 사용하면 `"1"`이 된다.  

`##` 연산자는 매개변수와 다른 요소를 <U>**문자열로 결합**</U>한다.  
예를 들어, `X ## [256]` 이라고 했을 때 매개변수로 `char`이라는 문자열이 들어오면 `char[256]`이 된다.

### 가변 인자 매크로

매크로에서 가변 인수를 받기 위해 `__VA_ARGS__`를 사용한다.

관련 예제는 [`ExtremeC_examples_chapter1_5.c`](/ExtreamC/chapter01/1.%20Preprocessor_Directives/ExtremeC_examples_chapter1_5.c)를 확인한다.  
전처리 단계 이후 코드는 [`ExtremeC_examples_chapter1_5.i`](/ExtreamC/chapter01/1.%20Preprocessor_Directives/ExtremeC_examples_chapter1_5.i)에 있다.

주의해야하는 것은 유사 함수 매크로의 정의에 세미콜론(`;`)이 없는 경우 개발자가 직접 붙여야 한다는 것이다.

### 루프 풀기

가변 인자 매크로를 통해 `루프 풀기`를 구현할 수 있다.

`for`이나 `while` 반복문을 통해 명령어를 반복하던 것을 단순히 명령어를 여러번 등장하게 작성하는 것이다.

관련 예제는 [ExtremeC_examples_chapter1_6.c](/ExtreamC/chapter01/1.%20Preprocessor_Directives/ExtremeC_examples_chapter1_6.c)와 [ExtremeC_examples_chapter1_6.i](/ExtreamC/chapter01/1.%20Preprocessor_Directives/ExtremeC_examples_chapter1_6.i)를 확인한다.

주의할 점은 가변 인자는 쉼표 단위로 분리되며,  
처리할 수있는 요소에 비해 더 적은 인수가 들어오면, 나머지는 빈 값으로 대체되고  
처리할 수 있는 요소에 비해 더 많은 인수가 들어오면, 나머지는 무시된다.  

루프 풀기는 임베디드 개발 환경과 같이 제한된 처리 능력 문제를 겪는 환경에서 사용된다.

루프 풀기를 통해 비선형적인 구조의 함수를 선형적으로 만들어서 <U>**루프 오버헤드**</U>(제어 흐름 변경)를 줄이는 최적화를 구현할 수 있다.

이러한 최적화는 적절한 자료구조와 알고리즘을 선정하고, 성능에 부합하는 복잡한 알고리즘으로 교체하는 등의 최적화가 선행되어야한다.

### 매크로의 장점과 단점

코드를 가독성을 높이고 반복되는 명령어를 걷어내서 유지보수성을 높일 수 있다.

> 추가로 매크로는 <U>**함수 호출로 발생하는 오버헤드**</U>(스택 프레임 메모리 할당, 매개변수 복사, 제어의 흐름 변경 등)를 줄일 수 있다. 즉, 함수 호출로 발생하는 비용이 수행되는 코드의 비용 크다면 매크로 사용을 고려할 수 있다.

하지만 매크로는 컴파일 이후에 모듈성이 사라진다는 단점이 있다.

또한 디버깅 시 매크로 확장 이전의 코드가 없다면 컴파일러가 보고하는 내용을 쉽게 이해할 수 없다.(~~현대 C 컴파일러는 전처리 단계 코드를 유지하고 오류 내용을 적절히 보고하기 때문에 큰 상관이 없다.~~)

소프트웨어 설계는 프로젝트를 비선형화 하는 것이다.
즉, 프로젝트가 소프트웨어 설계 원칙에 따른다면 <U>적용 가능한 최소 크기를 갖는 여러 개의 가벼운 이진파일</U>로 구성된다.

이러한 방식은 대체로 미미하지만 성능을 저하시킬 수 있다.

루프풀기를 예로 들면
매크로는 전처리 단계에서 대체된 후 사라지기 때문에
컴파일 단계에서 이미 모듈성이 사라진 코드로 변경된다.
결국 최종 이진 파일에는 모듈성이 다 사라진 코드만 남게 되는 것이다.

결론적으로 매크로는 성능과 설계 사이의 트레이드오프라고 할 수 있다.
따라서 구성원들과의 합의하에 선형적인 구조, 즉 매크로를 적절하게 사용해야한다.

## 조건부 컴파일

조건부 컴파일은 서로 다른 조건에 기반해 서로 다른 전처리된 소스코드를 갖게 하는 것이다.

`컴파일러`가 조건적으로 수행하는 것이 아니라, `전처리기`가 특정 조건에 따라 명령을 수행한다.

조건부 컴파일 지시자는 다음과 같다.
* `#ifdef`
* `#ifndef`
* `#else`
* `#elif`
* `#endif`
  
조건부 컴파일 지시자는 `if` 조건문과 비슷해서 [ExtremeC_examples_chapter1_7.c](/ExtreamC/chapter01/1.%20Preprocessor_Directives/ExtremeC_examples_chapter1_7.c)과 [ExtremeC_examples_chapter1_7.i](/ExtreamC/chapter01/1.%20Preprocessor_Directives/ExtremeC_examples_chapter1_7.i)를 비교하면 쉽게 알 수 있다.  
비교를 위해 `gcc`의 `-D` 옵션을 사용하여 매크로를 외부에서 정의했다.

### 헤더 가드 구문

조건부 컴파일은 주로 헤더가드 구문으로 사용된다.

컴파일 단위에서 정적 라이브러리 등 코드 덩어리가 중복 포함이 되지 않도록 `#ifdef` `#endif` 사이에 모든 변수와 함수를 선언하는 것이다.

`#pragma once`를 사용하면 한 줄로 적을 수 있어서 편하다.
`#ifdef`와 기능상 동일한데, 차이점은 `C`표준이 아니라는 것과 이식성이 필요할 때는 사용할 수 없다는 것이다.
하지만 거의 모든 전처리기에서 `#prama`를 지원한다.