# 전문가를 위한 C - Chapter 5 스택과 힙 : 힙

- [전문가를 위한 C - Chapter 5 스택과 힙 : 힙](#전문가를-위한-c---chapter-5-스택과-힙--힙)
  - [힙](#힙)
    - [힙 메모리의 할당과 해제](#힙-메모리의-할당과-해제)
      - [malloc](#malloc)
      - [memset](#memset)
      - [calloc](#calloc)
      - [realloc](#realloc)
      - [메모리 누수](#메모리-누수)
    - [leaks 코드 삽입](#leaks-코드-삽입)
    - [힘 메모리 원칙](#힘-메모리-원칙)
      - [소유권 전략](#소유권-전략)
    - [참고자료](#참고자료)

## 힙

힙은 스택보다 느리지만 여러가지 장점이 있다.

1. 힙은 자동으로 할당되는 블록이 없다.
   * 대입 연산자(`=`)를 사용하여 자동으로 할당되는 스택과 달리
   * `malloc`과 같은 함수를 사용하여 힙 메모리 블록을 얻어야한다.
2. 힙 메모리 블록의 주소를 지정할면 반드시 `포인터`를 사용해야한다.
   * 모든 힙 영역은 주소를 통해 사용해야한다.
3. 힙에 할당된 변수는 스코프를 갖지않는다.
   * 스택과 달리 힙에 할당된 변수는 개발자가 직접 `생명주기`를 관리해야한다.
   * 따라서 `소유자 전략`, `가비지 컬렉터` 등과 같은 메모리 블록의 스코프와 소유자를 위한 새로운 전략이 필요하다.
4. 힙 메모리 내 메모리의 할당과 해제는 개발자가 해야한다.
   * `free` 함수를 사용하여 메모리를 해제해한다.
   * 해제하지 않는다면 `메무리 누수`가 발생하고, 대부분의 경우 오류를 발생시킨다.
5. 힙 세그먼트를 검사하기 위해서는 디버거를 사용해야한다.
   * 스택과 동일하다.
   * macOS에서는 `leaks` 유틸리티를 사용하여 메모리 누수를 검사할 수 있다.
6. 힙은 메모리 크기가 크다
   * 주소값이 작아지는 특징때문에 크기가 제한되는 스택과 달리
   * 힙은 크기가 커질수록 OS에 더 많은 힙 페이지를 요청한다.
   * 힙은 주소값이 점점 커진다.

### 힙 메모리의 할당과 해제

`힙 메모리`는 일련의 함수나 API를 사용하여 메모리 블록을 할당하거나 헤제한다.

`힙 메모리 블록`을 할당 및 해제하기 위한 함수는 `stdlib.h`에 정의되어있다.

#### malloc

`malloc`은 Memeory Allocation을 의미한다.

`malloc`의 원형은 다음과 같다.

```C
#include <stdlib.h>
void *malloc(size_t size);  
```

`malloc`은 할당받고자하는 `메모리 크기`를 바이트 단위로 전달받고,
할당된 메모리 블록의 첫 번째 주소값을 [`제네릭 포인터`(`void *`)](/chapter01/2.%20Pointer_Variable/README.md#제네릭-포인터)로 반환한다.

주소값을 반환받기 때문에 힙 영역에 할당된 메모리 공간으로 접근하려면 **반드시** 포인터를 사용해야한다.

힙 영역에 할당할 수 있는 적당한 블록이 없을 때에는 `널 포인터`를 반환한다.

`malloc`은 해당 메모리 블록에 접근할 때까지 할당을 지연시키는 방식으로 최적화된다. 이는 `calloc`과 구별되는 특징이다.

`malloc`으로 할당받은 메모리를 초기화하기 위해서는 `memset` 함수를 사용한다.

#### memset

`memset` 함수는 `string.h` 헤더 파일에 정의되어 있다.

`memset`의 원형은 다음과 같다.

```C
#include <string.h>
void *memset(void *dest, int c, size_t count);
```

`memset`은 `dest`에서부터 `count`만큼 `c`값으로 채운다.

이때 `c`의 값은 `부호 없는 문자`로 변환된다.

`memset()` 함수는 `dest`에 대한 `포인터`를 반환한다.

#### calloc

`calloc`은 `malloc`과 마찬가지로 힙 영역에 메모리를 동적으로 할당해주는 함수이다.

하지만 `calloc`은 `malloc`과 다르게
할당하고자 하는 메모리의 크기를 두 개의 인수로 나누어 전달받고,
할당받은 메모리의 모든 비트값을 전부 0으로 초기화한다.

`calloc` 함수의 원형은 다음과 같다.

```C
#include <stdlib.h>
void *calloc(size_t nmemb, size_t size);
```

`nmemb`은 메모리 블록의 개수를 의미하고, `size`는 각 블록의 바이트 수를 의미한다. 즉, `calloc`은 `size` 크기의 바이트를 가진 데이터를 `nmemb`개 할당받을 수 있는 메모리 블록을 할당한다.

다음은 같은 기능을 수행하는 `malloc`과 `calloc`이다.

```C
int *ptr1 = (int *)malloc(10 * sizeof(int));
int *ptr2 = (int *)calloc(10, sizeof(int));
```

`calloc`은 `malloc`에 비해 메모리의 모든 값을 0으로 초기화한다는 장점갖는다.

하지만 `malloc`은 초기화를 하지 않을 뿐더러, 메모리에 접근하기 전까지 할당을 지연하기 때문에 `calloc`보다 빠르다.

#### realloc

`realloc`은 이전 블록의 데이터를 변경하지 않고 이미 할당된 블록을 확장한다.

만약 `단편화`(`fragmentation`) 때문에 더 이상 확장할 수 없을 때는 다른 충분한 블록을 찾아서 새로운 블록에 데이터를 복제한다. 이때 이전의 블록은 할당이 자동으로 해제된다.

`realloc`은 많은 단계를 거치기 때문에 가장 느리다.

다음은 `reallc` 함수의 원형이다.

```C
#include <stdlib.h>
void *realloc(void *ptr, size_t size);
```

`ptr`은 바꾸고자 하는 메모리 공간의 포인터이며, `size`는 해당 메모리 공간에 재할당할 크기이다.
`ptr`로 `NULL`이 전달되면, `malloc`과 동일한 동작을 수행한다.

#### 메모리 누수

`ExtremeC_examples_chapter5_4`는 메모리 누수 예제이다.
메모리 누수는 기술부채이며, 추후에 문제가 되는 위험요인이다.
힙 메모리는 항상 해제해야하며, 프로그램 작성시 항상 메모리 누수를 확인해야한다.

### leaks 코드 삽입

macOS에는 `valgrind`가 기본 유틸리티로 내장되어있지 않다.
따라서 `memory leak`을 확인하는데 기본 유틸리티인 `leaks`를 사용한다.
하지만 `leaks`를 사용하려면 프로세스가 실행중이어야한다는 단점이 있다.

따라서 다음같이 `leaks` 명령어를 <U>코드에 삽입</U>하면 보다 편하게 사용할 수 있다.

```C
#include <stdlib.h> // system, atexit 함수를 위한 라이브러리

void leaks(void)
{
  system("leaks a.out");
}

int main(void)
{
  // ...

  atexit(leaks);
  return (0);
}
```

### 힘 메모리 원칙

모든 `스택`의 메모리 블록은 <U>>**스코프를 갖는다**</U>. 메모리 블록의 수명은 스코프에 의해 정의된다. 스코프를 벗어나면 해당 스코프에서 정의된 모든 변수는 사라진다.

하지만 `힙`의 메모리 블록은 <U>**스코프를 갖지 않는다**</U>.
따라서 개발자가 스코프를 수동으로 정의하거나 가비지 컬렉터를 사용하여 메모리 블록의 수명을 관리해야한다.

책에서는 힙 메모리 관리에 대한 전략 중 `소유권 전략`을 예시로 보여준다.

#### 소유권 전략

소유권 전략은 힙 메모리 블록의 소유자를 정의하는 방법 중 하나이다.

힙 메모리 블록에 대한 소유권을 갖는 객체 혹은 함수를 결정하고

힙 메모리 블록 생명주기의 책임을 해당 소유자가 갖도록 하는 것이다.

즉, 소유권을 가진 객체 혹은 함수가 메모리 블록을 할당하고 해제하는 모든 책임을 갖는 것이 소유권 전략이다.


ExtremeC_examples_chapter5_5 예시에서는
`큐 객체`가 `queue_t 구조체의 arr배열`에 대한 소유권을 갖고, `main 함수`가 `큐 인스턴스 q`에 대한 소유권을 갖는다.

각 메모리 블록에 대한 할당과 해제를 **주석으로 명시**했다는 것을 주의깊게 봐야한다.

힙 메모리 블록의 생명주기 관리에 대한 전략과 전략에 대한 가정을 기록해두면
* 디버깅 단게에서 메모리 누수를 확인하기 전에 코드 작성 단계에서 메모리 누수를 유추할 수 있으며,
* 나중에 코드를 보더라도 어떤 전략을 사용했는지 쉽게 알수 있다.

추가로 `C`도 `Java`와 마찬가지로 `Boehm-Demers-Weiser Conservative` 등의 가비지 컬렉터가 있다.

### 참고자료
> [leaks 1.2배 더 유용하게 사용하기](https://80000coding.oopy.io/457f637f-b101-4f79-adc8-0ca72bd3c6f3)  
> [메모리의 동적 할당
](http://www.tcpschool.com/c/c_memory_malloc)  
> [memset() — 바이트를 값으로 설정](https://www.ibm.com/docs/ko/i/7.3?topic=functions-memset-set-bytes-value)  