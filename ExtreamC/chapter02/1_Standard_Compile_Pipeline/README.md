# 전문가를 위한 C - Chapter 2 소스 코드에서 이진 파일로 : 표준 컴파일 파이프라인

- [전문가를 위한 C - Chapter 2 소스 코드에서 이진 파일로 : 표준 컴파일 파이프라인](#전문가를-위한-c---chapter-2-소스-코드에서-이진-파일로--표준-컴파일-파이프라인)
  - [표준 컴파일 파이프라인](#표준-컴파일-파이프라인)
    - [헤더파일과 소스파일](#헤더파일과-소스파일)
    - [빌드하기](#빌드하기)
    - [1단계 : 전처리](#1단계--전처리)
    - [2단계 : 컴파일](#2단계--컴파일)
    - [3단계 : 어셈블리](#3단계--어셈블리)
    - [4단계 : 링크](#4단계--링크)



## 표준 컴파일 파이프라인

`.C` 파일을 컴파일 하는데는 4가지 요소로 구성된 `파이프라인`이 실행된다.

> `Preprocessor` - `Compiler` - `Assembler` - `Linker`  
> `전처리기` - `컴파일러` - `어셈블러` - `링커`

각 파이프라인 컴포넌트는 이전 요소로부터 `입력값`을 받고, 다음 컴포넌트를 위한 `결과값`을 생성한다.  
이 과정은 `최종 결과물`이 만들어질 때 까지 계속된다.  
또한 컴포넌트 중 어느 하나라도 실패하면 오류가 발생힌다.

앞의 세 단계 `Preprocessor - Compiler - Assembler`가 완료되면
`재배치 가능한 목적파일`(relocatable obejct file)들이 생성되고,  
마지막 `Linker` 단계에서 이를 사용하여 `실행 가능한 목적파일`(executable object file)을 만든다. 즉, `실행 가능한 목적파일`은 이미 준비된 `재배치 가능한 목적파일` 여러개를 합쳐서 만든다.

`플랫폼`이란 특정 `하드웨어`(`CPU`)와 그 하드웨어에서 사용하는 `소프트웨어`(`OS`)의 결합이다.  
`크로스 플랫폼`이란 각 플랫폼에 따른 서로 다른 이진파일을 생성할 수 있는 것인 반면, `이식 가능성`은 모든 플랫폼에서 같은 이진파일을 사용하는 것이다.  
`C`는 크로스 플랫폼이며, 이식 가능성에 대한 예시로는 `Java`가 있다.

### 헤더파일과 소스파일

C언어 소스코드는 대부분 `헤더파일`(`.h`)과 `소스파일`(`.c`)을 나눈다.

헤더파일은 주로 다음 내용을 포함한다.

* `열거형`(`enum`)
* `매크로`(`#define`)
* `형식정의`(`typedef`)
* `함수의 선언`
* `전역변수`
* `구조체`(`struct`)

일반적으로 헤더 파일에는 `함수의 선언`만 두고, `함수의 정의`는 그에 맞는 소스파일로 옮기기를 권장한다. 반면 `구조체`는 선언과 정의를 분리하지 않고, 상속과 관련된 특별한 경우에만 서로 다른 파일에 둔다.

다음은 함수의 선언과 정의를 헤더파일과 소스파일로 분리한 예시이다.
```C
#ifndef EXTREMEC_EXAMPLES_CHAPTER_2_1_H
#define EXTREMEC_EXAMPLES_CHAPTER_2_1_H

double avg(int*, int);

#endif
```

```C
#include "ExtremeC_examples_chapter2_1.h"

double	avg(int *array, int length)
{
	// ...
}
```

위 예시에서 헤더파일은 `헤더 가드 구문`으로 중복 포함이 보호된다.

### 빌드하기

프로젝트를 빌드한다는 것은
`소스코드` 내 모든 `소스파일`(`.c`)들을 컴파일하여 `재배치 가능한 목적파일`(`.o`)로 만들고,
이들을 결합하여 `정적 라이브러리` 또는 `실행 이진 파일`로 만든다는 것이다.

여기에는 2가지 중요한 규칙이 있다.
1. `소스 파일`(`.c`)만 컴파일 한다. `헤더 파일`(`.h`)은 컴파일 대상이 아니다.
2. 각 소스 파일을 <U>따로따로 컴파일</U> 한다. 소스 파일이 2개라면 컴파일러를 2번 수행해야한다.

소스 파일을 컴파일할 때 다른 소스 파일은 컴파일 되지 않는다.
만약 헤더 파일에 C 코드가 포함되어 있어도, 해당 헤더파일을 소스 파일에 포함시킨 뒤 <U>`소스파일`을 컴파일</U>한다.

이에 대한 예시는 [`ExtremeC_examples_chapter2_1.c`](./ExtremeC_examples_chapter2_1.c)와 [`ExtremeC_examples_chapter2_1.i`](./ExtremeC_examples_chapter2_1.i)를 비교한다.

### 1단계 : 전처리

* 입력값 : `소스 파일`(`.c`)
* 결과값 : `변환 단위`(`.i`)

컴파일 파이프라인의 첫 번째 단게는 전처리이다.

`전처리기`는 헤더파일의 내용을 모아서 하나의 C 코드 몸체로 만든다.
즉, 전처리 단계 이후에는 `헤더 파일`의 내용이 `소스 파일`로 복사된다.

또한 `전처리기`는 모든 `전처리기 지시자`를 처리한다.
전처리가 완료된 코드는 모든 전처리 지시자가 변환된 `변환단위`이다.
즉, `변환단위`는 헤더파일의 모든 C 코드가 포함되고, 모든 전처리 지시자가 변환된 코드이다.

`gcc`에서 `-E` 옵션을 사용하면 [`ExtremeC_examples_chapter2_1.c`](./ExtremeC_examples_chapter2_1.c) 코드를 변환단위로 `덤프`할 수 있다.

이때 [`ExtremeC_examples_chapter2_1.h`](./ExtremeC_examples_chapter2_1.h)에서 `#ifndef`를 `#ifdef`로 바꿔보면 덤프된 변환단위 코드에 헤더파일의 내용이 포함되지 않은 것을 볼 수 있다.  
즉, <U>모든 헤더파일의 C 코드는 전처리 단계 이후 `변환 단위`로 복제</U>된 것이다.

정리하자면 전처리 단계에서 `입력값`은 `소스 파일`이며, `결과값`은 그에 해당하는 `변환단위`이다.  

### 2단계 : 컴파일

* 입력값 : `변환단위`(`.i`)
* 결과값 : `어셈블리 코드`(`.s`)

두번째 단계인 컴파일 단계를 진행하면 컴파일러는 <U>**머신 의존적인**</U> 어셈블리 코드를 출력한다.

어셈블리 코드는 `아키텍처`마다 상이하다.
컴파일러는 변환 단위를 `구문 분석`(parsing)하여 이를 대상 아키텍처에 맞는 `어셈블리 코드`로 `변환`한다.

예를 들어 같은 코드여도 `AMD 64비트 아키텍처`와 `Intel x86 64비트 아키텍처`에서 변환된 어셈블리 코드는 서로 다르다.

`gcc`에서 `-S` 옵션을 사용하면 어셈블리 코드를 `덤프`할 수 있다.

### 3단계 : 어셈블리

* 입력값 : `어셈블리 코드`(`.s`)
* 결과값 : `재배치 가능한 목적파일`(`.o`)

각 아키텍처는 고유의 `어셈블러`(`Assembler`)를 갖는다.
어셈블러는 고유한 어셈블리 코드를 해당 아키텍처의 기계어로 변환할 수 있다.

`목적파일`이란 기계 수준의 명령어를 포함하는 파일이다.
목적파일은 그 자체로 최종 결과물이 될 수도 있지만,
여기서 집중하고자 하는 것은 `재배치 가능한 목적파일` 이다.

`재배치 가능한 목적파일`은 빌드 단계에서 얻을 수 있는 중요한 `임시 파일`이자 `중간 목적 파일`이라고 할 수 있다.

어셈블리는 <U>하나의 소스 파일</U>을 컴파일하는 마지막 단계이다. 즉, 소스 파일 하나에 해당하는 `재배치 가능한 목적 파일`을 얻으면 컴파일이 완료된 것이다. 

하지만 <U>`재배치 가능한 목적 파일`은 `실행 파일`이 아니다.</U>  
앞서 [`표준 컴파일 파이프라인`](#표준-컴파일-파이프라인)에서 설명했듯이 여러개의 `재배치 가능한 목적파일`을 <U>결합하여</U> 최종 결과물을 만든다. 즉, 각각의 소스 코드에 대한 컴파일은 완료되었으나, 이후 `링크` 단게에서 목적파일들을 결합하여 `최종 실행 파일`을 만든다.

`UNIX` 계열 `OS`에서 어셈블러 도구는 `as`이다.  
```shell
as <assembly_code.s> -o <dest_obj_file.o>
```  
위 명령어를 통해 어셈블리 코드에서 목적파일을 생성할 수 있다.

하지만 어셈블러를 직접 사용하는 것보다는 컴파일러를 사용하여 `as`를 간접적으로 호출하는 것을 권장한다.
`gcc`에서 `목적파일`(`.o`)을 만드는 옵션은 `-c` 이다.

참고로 `컴파일`이라는 용어는 두 번째 단계뿐만 아니라 컴파일 파이프라인 전체를 아우르는 `빌드`라는 의미로 사용하기도 한다.

### 4단계 : 링크

`아키텍처`란 제조사가 만든 일련의 프로세서이다.
이 프로세서는 특정 `명령어 집합`을 실행한다.
제조사는 자사의 아키텍처를 위한 `어셈블리어`를 설계한다.

따라서 새로운 아키텍처를 지원하기 위해서는 먼저 해당 아키텍처를 위해 설계된 `어셈블리어`를 알아야한다.
또한 제조사에서 개발된 `어셈블러 도구`(해당 어셈블리어를 기계어로 변환하는 도구)가 필요하다.

어셈블러 도구에는 3단계에서 알아본 `어셈블러`와 4단계에서 알아 볼 `링커`가 있다.

어셈블러와 링커는 컴파일러와 별도로 실행이 가능하다.
UNIX계열 기준으로 어셈블러는 `as`, 링커는 `ld`(load의 약자) 기본적으로 탑재되어있다.

ld를 통해 실행파일을 만드려면 필요한 목적파일과 옵션이 더 많기 때문에 직접 링크하는 것은 쉽지 않다.

따라서 gcc 컴파일러를 통해 간접적으로 링크하는 것이 좋다.
gcc에서 링크를 위해 다음과 같이 실행하면 된다.
```bash
gcc imple.o main.o
```

