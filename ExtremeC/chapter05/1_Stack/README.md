# 전문가를 위한 C - Chapter 5 스택과 힙 : 스택

- [전문가를 위한 C - Chapter 5 스택과 힙 : 스택](#전문가를-위한-c---chapter-5-스택과-힙--스택)
  - [스택](#스택)
    - [스택 검사하기](#스택-검사하기)
    - [스택 메모리 사용 시 주의점](#스택-메모리-사용-시-주의점)
    - [lldb 실습을 위한 명령어](#lldb-실습을-위한-명령어)
  - [참고자료](#참고자료)
    - [GDB to LLDB command map](#gdb-to-lldb-command-map)

## 스택

### 스택 검사하기

배열 arr로 시작하는 메모리의 바이트를 출력하면 다음과 같다.
```zsh
(lldb) m read -s 1 -f x -c 4 0x000000016fdff02c
0x16fdff02c: 0x41 0x42 0x43 0x44
```

다음은 전체를 출력한 결과이다.
```zsh
(lldb) m read 0x000000016fdff02c
0x16fdff02c: 41 42 43 44 c0 f2 df 6f 01 00 00 00 01 00 00 00  ABCD...o........
0x16fdff03c: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
```

`스택`은 다른 메모리 영역과는 다르게 <U>**큰 주소**에서 **주소값이 작아지는 방향**</U>으로 채워진다.

맨 앞의 `41 42 43 44`은 `arr`에 저장한 `A`, `B`, `C`, `D`에 해당하는 `16진수` `ASCII` 값이다.

그 뒤에 이어지는 다른 값들은 `main` 함수에 진입하기 전에 푸시된 스택 프레임 안에 존재하는 바이트이다.  

만약 할당하지 않은 주소에 있는 스택 내용을 수정한다면 충돌을 일으키거나 갑자기 종료된다. 

스택 메모리에서 주소는 점점 작아지기 때문에 변수나 배열의 경계를 넘어가서 값을 쓰게된다면 이미 작성된 바이트를 덮어쓰게된다.  

따라서 스택 변수를 작성할 때는 <U>**변수나 배열이 정의된 경계 바깥에 값을 쓰지않도록 주의**</U>해야한다.

### 스택 메모리 사용 시 주의점

`스코프`란 변수, 함수 혹은 기타 식별자가 정의되고 유효할 수 있는 범위를 말한다. 스택 변수는 고유의 스코프를 갖고, <U>스코프는 변수의 수명을 결정</U>한다.

일반적으로 사용되는 스코프의 종류는 `함수 스코프`, `블록 스코프`, `파일 스코프`이다.

`함수 스코프`란 특정 함수 내에서 선언된 변수의 유효범위이다. 함수안에서 선언된 변수는 오직 함수 내에서만 유효하다.

`블록 스코프`란 {} 블록 안에서 정의된 변수의 유효범위이다. 함수나 반복문, 조건문의 {} 블록 내에서 선언된 변수는 오직 블록 안에서만 유효하다.

`파일 스코프`란 전역변수와 같이 함수나 {} 블록 바깥에 선언된 변수의 유효범위이다. 파일 스코프를 갖는 변수는 선언된 위치부터 프로그램의 종료까지 유효하다.


스택 세그먼트에서 스택 변수는 가장 윗부분에 할당된다.
스택 변수의 수명은 변수가 스택 세그먼트에 할당될 때 시작한다.
이후 다른 변수나 스택 세그먼트가 위에 올라가 있는 한 해당 변수는 살아남는다.
하지만 변수가 스택에서 pop되면 수명이 종료되고 메모리가 자동으로 해제된다.

ExtremeC_examples_chatper5_2.c를 보면
get_integer 함수에서 지역 변수 var의 포인터를 반환한다.

하지만 var은 get_integer가 종료되면서 할당이 해제된다.
따라서 main 함수에 반환된 포인터는 허상포인터가 된다.

이를 방지하기 위해서 일반적으로 <U>`호출하는 함수`의 변수의 주소(포인터)</U>를 <U>`호출되는 함수`에 포인터로 전달</U>하는 방식을 사용한다.

`호출하는 함수`에서 `변수의 주소`를 전달하면 `호출되는 함수`가 다른 함수를 추가로 호출하더라도 해당 `변수`는 `호출하는 함수`가 종료될 때까지 계속 살아남게된다.

### lldb 실습을 위한 명령어

`macOS`는 `gdb` 대신 `lldb`를 네이티브로 사용한다.
따라서 여기서는 책 내용을 실습하기 위한 `lldb` 명령어를 정리한다.

디버깅을 사용하기 위해서는 이진 파일에 디버깅을 위한 `디버그 심벌`을 추가해야한다. `gcc`의 `-g` 옵션을 사용하여 `디버그 심벌`을 추가할 수 있다. `gcc` `-g` 옵션 사용하지 않아도 `lldb`를 실행할 수 있지만, 어셈블리 단위로 실행된다. `C` 코드 단위로 디버깅을 하기 위해서는 반드시 `-g` 옵션을 통해 `디버그 심벌`을 추가해야한다.

`lldb` 실행
```zsh
lldb ex5_1.out
```

`main` 함수에 `BreakPoint` 설정
```zsh
(lldb) breakpoint set --name main
(lldb) break set --name main
(lldb) break set -n main
(lldb) b main
```

프로세스 실행
```zsh
(lldb) run <args>
(lldb) r <args>
```

현재 스레드에서 `Step-In` 수행 : 현재 라인 수행하고, 함수 호출이 있는 경우 <U>해당 함수로 진입</U>
```zsh
(lldb) thread step-in
(lldb) step
(lldb) s
```

현재 스레드에서 `Step-Over` 수행 : 현재 라인 수행하고, 함수 호출이 있는 경우 <U>해당 함수를 완전히 실행함</U>
```zsh
(lldb) thread step-over
(lldb) next
(lldb) n
```

현재 스레드에서 `Step-Out` 수행 : 현재 함수를 완료하고, 함수 호출 지점으로 돌아감
```zsh
(lldb) thread step-out
(lldb) finish
(lldb) fin
```

모든 지역 변수들과 변수 내용 출력
```zsh
(lldb) frame variable
(lldb) frame var
(lldb) var
(lldb) v
```

지역변수 "arr"의 내용 출력
```zsh
(lldb) v arr
```

지역변수 "arr"의 주소 출력
```zsh
(lldb) v &arr
```

배열 arr로 시작하는 메모리의 바이트 프린트하기
```zsh
(lldb) memory read --size 1 --format x --count 4 0x000000016fdff02c
0x16fdff02c: 0x41 0x42 0x43 0x44

(lldb) m read -s 1 -f x -c 4 0x000000016fdff02c
0x16fdff02c: 0x41 0x42 0x43 0x44
```


프로세스 디버깅 중에 특정 표현식 실행 
```zsh
(lldb) expr arr[1] = 'F'
(lldb) e arr[1] = 'F'
(lldb) print arr[1] = 'F'
(lldb) p arr[1] = 'F'
```

## 참고자료

### [GDB to LLDB command map](https://lldb.llvm.org/use/map.html)



